/* 
SPDX-FileCopyrightText: 2023 Kevin de Jong <monkaii@hotmail.com>

SPDX-License-Identifier: GPL-3.0-or-later
*/

import { IDataSource } from "./datasources";
import * as debian from "./debian";
import { ISourceFile } from "./interfaces";
import * as crypto from "crypto";

type IFileType =
  | "SOURCE"
  | "BINARY"
  | "ARCHIVE"
  | "APPLICATION"
  | "AUDIO"
  | "IMAGE"
  | "TEXT"
  | "VIDEO"
  | "DOCUMENTATION"
  | "SPDX"
  | "OTHER";

/**
 * SPDX File
 * @interface IFile
 * @member SPDXID SPDX identity of the file
 * @member annotations Annotations
 * @member checksums Checksums
 * @member comment Comments
 * @member fileContributors List of contributors
 * @member fileName Filename
 * @member fileTypes List of file types
 * @member licenseComments License comments
 * @member licenseConcluded License concluded
 * @member licenseInfoInFiles List of licenses
 * @member notice Notice
 * @member attributionText Attribution text
 * @see https://spdx.github.io/spdx-spec/4-file-information/
 */
interface IFile {
  SPDXID: string;
  annotations?: {
    annotationDate: string;
    annotationType: string;
    annotator: string;
    comment?: string;
  }[];
  checksums: {
    algorithm: string;
    checksumValue: string;
  }[];
  comment?: string;
  copyrightText?: string;
  fileContributors: string[]; // 0..*
  fileName: string;
  fileTypes: IFileType[]; // 0..*
  licenseComments?: string;
  licenseConcluded?: string;
  licenseInfoInFiles: string[]; // 0..*
  notice?: string;
  attributionTexts: string[]; // 0..*
}

/**
 * SPDX Relationship
 * @interface IRelationship
 * @member spdxElementId The SPDX ID of the element
 * @member relationshipType The type of relationship
 * @member relatedSpdxElement The SPDX ID of the related element
 * @see https://spdx.github.io/spdx-spec/3-relationships-between-SPDX-elements/
 */
interface IRelationship {
  spdxElementId: string;
  relationshipType: "DESCRIBES";
  relatedSpdxElement: string;
}

/**
 * Simplified implementation of the SPDX 2.3 specification,
 * used for generating a Software Bill of Materials for the
 * files scanned against REUSE compliance.
 * @interface ISoftwareBillOfMaterials
 * @member SPDXID SPDX identity of the document
 * @member spdxVersion SPDX version reference
 * @member name Name of the document as designated by the creator
 * @member documentNamespace SPDX document-specific namespace as a unique absolute URI
 * @member dataLicense License of the SPDX document
 * @member creationInfo Information about the creation of the SPDX document
 * @member relationships Relationships between SPDX elements
 * @member files List of files
 * @see https://spdx.github.io/spdx-spec/2-document-creation-information/
 * @see https://spdx.github.io/spdx-spec/3-relationships-between-SPDX-elements/
 * @see https://spdx.github.io/spdx-spec/4-file-information/
 */
interface ISoftwareBillOfMaterials {
  SPDXID: string;
  spdxVersion: string;
  name: string;
  documentNamespace: string;
  dataLicense: string;
  creationInfo?: {
    comment: string;
    created: string;
    creators: string[];
    licenseListVersion?: string;
  };
  relationships: IRelationship[];
  files: IFile[];
}

class SoftwareBillOfMaterials implements ISoftwareBillOfMaterials {
  SPDXID = "SPDXRef-DOCUMENT";
  spdxVersion = "SPDX-2.3";
  dataLicense = "CC0-1.0";
  documentNamespace = "http://spdx.org/spdxdocs/spdx-v2.3-45eae250-b782-46dd-9723-62ec3bed2a7c";

  name: string;
  creationInfo?: {
    comment: string;
    created: string;
    creators: string[];
    licenseListVersion?: string;
  } = undefined;

  relationships: IRelationship[] = [];
  files: IFile[] = [];

  datasource: IDataSource;

  constructor(name: string, datasource: IDataSource) {
    this.name = name;
    this.datasource = datasource;
    this.creationInfo = {
      comment: "Generated by ReuseMe",
      created: new Date().toISOString(),
      creators: ["Tool: ReuseMe-v0"],
    };
  }

  /**
   * Creates a single SPDX File entry for the provided file.
   * @param file The file to create the SPDX entry for
   * @param debianLicenseMap Debian package configuration mapping against the file
   * @returns The SPDX File entry
   */
  private async createFile(file: ISourceFile, debianLicenseMap: Map<string, IFile>) {
    const fileName = file.source === "original" ? file.filePath : file.licensePath;
    // Determine the SPDX header of the file
    let spdxFile = parseFile(fileName, await this.datasource.getFileContents(file.filePath));

    // First we check whether the file is matched in the Debian package configuration
    const debianFileLicense = debianLicenseMap.get(file.filePath);
    if (debianFileLicense !== undefined) {
      spdxFile = debianFileLicense;
    }

    // Next we check for an available .license file, as part of optimization for large
    // binary files.
    if (isReuseCompliant(spdxFile) === false) {
      spdxFile = parseFile(fileName, await this.datasource.getFileContents(file.licensePath));
    }

    // Otherwise, we check the original file.
    if (isReuseCompliant(spdxFile) === false) {
      spdxFile = parseFile(fileName, await this.datasource.getFileContents(file.filePath));
    }

    return spdxFile;
  }

  /**
   * Creates a list of SPDX File entries based on the current datasource.
   * @returns The list of files
   */
  private async gatherFiles(): Promise<IFile[]> {
    const changedFiles = await this.datasource.getChangedFiles();
    const debianConfig = debian.load(await this.datasource.getFileContents(".reuse/dep5"));
    const debianLicenseMap = debianConfig ? debian.licenseMap(debianConfig, changedFiles) : new Map<string, IFile>();

    // Validate each file asynchronously
    const promises = [];
    for (let file of changedFiles) {
      // Skip files in the LICENSES/ directory
      if (file.filePath.startsWith("LICENSES/") || file.filePath === ".reuse/dep5") continue;
      // Skip original source files which have been removed
      if (file.source === "original" && file.modification === "removed") continue;

      promises.push(this.createFile(file, debianLicenseMap));
    }

    return await Promise.all(promises);
  }

  async generate() {
    this.files = await this.gatherFiles();
    this.files.forEach(file => {
      this.relationships.push({
        spdxElementId: "SPDXRef-DOCUMENT",
        relationshipType: "DESCRIBES",
        relatedSpdxElement: file.SPDXID,
      });
    });
  }

  /**
   * Converts the SPDX document to a JSON object.
   * @returns The SPDX document as a JSON object
   */
  toJSON(): ISoftwareBillOfMaterials {
    return {
      SPDXID: this.SPDXID,
      spdxVersion: this.spdxVersion,
      name: this.name,
      documentNamespace: this.documentNamespace,
      dataLicense: this.dataLicense,
      creationInfo: this.creationInfo,
      relationships: this.relationships,
      files: this.files,
    };
  }
}

/**
 * Creates a SPDX File entry for the provided file
 * @param fileName Filename of the file
 * @param contents Contents of the file
 * @returns SPDX File entry
 */
const parseFile = (fileName: string, contents: string): IFile => {
  let file: IFile = {
    SPDXID: `SPDXRef-${crypto.createHash("SHA1").update(fileName).digest("hex")}`,
    checksums: [
      {
        algorithm: "SHA1",
        checksumValue: crypto.createHash("SHA1").update(contents).digest("hex"),
      },
    ],
    fileContributors: [],
    fileName: fileName.startsWith("./") ? fileName : `./${fileName}`,
    fileTypes: [],
    licenseInfoInFiles: ["NOASSERTION"],
    licenseConcluded: "NOASSERTION",
    attributionTexts: [],
  };

  // REUSE-IgnoreStart
  const SPDXLicenseHeaderRegex = /SPDX-License-Identifier:\s*(?<identifier>[A-Za-z0-9-.]+)/g;

  const SPDXCopyrightRegex =
    /(Â©|[Cc]opyright|\([Cc]\))*\s*(?<year>[\d,-\s]*)\s*(?<copyrightHolder>[^\<\n]*)\s(<(?<contactAddress>.*)>)?/;
  const SPDXFileTagRegex = /SPDX-File(?<key>[A-Za-z]*):\s*(?<value>.*)/g;

  const ReuseIgnoreRegex = /REUSE-IgnoreStart[\s\S]*REUSE-IgnoreEnd/g;
  // REUSE-IgnoreEnd

  // Remove all REUSE-Ignore blocks from the file
  const strippedContents = contents.replace(ReuseIgnoreRegex, "");

  // Ensure that this file contains the minimum set of headers to be REUSE 3.0 compliant
  const licenseMatches = strippedContents.matchAll(SPDXLicenseHeaderRegex);
  for (const match of licenseMatches) {
    if (match?.groups === undefined) continue;
    const license = match.groups?.identifier.trim();
    if (file.licenseInfoInFiles.includes(license) === false) file.licenseInfoInFiles.push(license);
  }

  const fileTagMatches = strippedContents.matchAll(SPDXFileTagRegex);

  for (const match of fileTagMatches) {
    if (match?.groups === undefined) continue;
    const key = match.groups.key.trim();
    const value = match.groups.value.trim();

    switch (key) {
      case "AttributionText":
        file.attributionTexts.push(value);
        break; // TODO: Multiline support
      case "Comment":
        file.comment = value;
        break; // TODO: Multiline support
      case "Contributor":
        file.fileContributors.push(value);
        break;
      case "CopyrightText":
        if (file.copyrightText === undefined && SPDXCopyrightRegex.test(value)) file.copyrightText = value;
        break; // TODO: Multiline support
      case "LicenseComments":
        file.licenseComments = value;
        break; // TODO: Multiline support
      case "LicenseConcluded":
        file.licenseConcluded = value;
        break;
      case "LicenseInfoInFile":
        if (file.licenseInfoInFiles.includes(value) === false) file.licenseInfoInFiles.push(value);
        break;
      case "Notice":
        file.notice = value;
        break; // TODO: Multiline support
      case "Type":
        file.fileTypes.push(value as IFileType);
        break; // TODO: Literal type checking
    }
  }

  if (file.licenseInfoInFiles.length > 1) {
    // Remove the element "NOASSERTION" if there are other licenses specified in the "LicenseInfoInFile
    file.licenseInfoInFiles = file.licenseInfoInFiles.filter(license => license !== "NOASSERTION");
  }

  return file;
};

const hasValidLicense = (file: IFile): boolean => {
  return (
    file.licenseInfoInFiles.length > 0 &&
    !(file.licenseInfoInFiles.length === 1 && file.licenseInfoInFiles[0] === "NOASSERTION")
  );
};

const hasValidCopyrightText = (file: IFile): boolean => {
  return file.copyrightText !== undefined && file.copyrightText !== "";
};

/**
 * Validates whether the provided header is a valid SPDX header.
 * @param header SPDX header to validate
 * @returns True if the header is valid, false otherwise
 */
const isReuseCompliant = (file: IFile): boolean => {
  return hasValidLicense(file) && hasValidCopyrightText(file);
};

export { SoftwareBillOfMaterials, hasValidCopyrightText, hasValidLicense, isReuseCompliant, parseFile, IFile };
