/* 
SPDX-FileCopyrightText: 2023 Kevin de Jong <monkaii@hotmail.com>

SPDX-License-Identifier: GPL-3.0-or-later
*/

import { IDataSource } from "./datasources";
import * as debian from "./debian";
import { ISourceFile } from "./interfaces";
import * as crypto from "crypto";
import { getSourceFile } from "./utils";
import * as commentIt from "@dev-build-deploy/comment-it";

type IFileType =
  | "SOURCE"
  | "BINARY"
  | "ARCHIVE"
  | "APPLICATION"
  | "AUDIO"
  | "IMAGE"
  | "TEXT"
  | "VIDEO"
  | "DOCUMENTATION"
  | "SPDX"
  | "OTHER";

/**
 * SPDX File
 * @interface IFile
 * @member SPDXID SPDX identity of the file
 * @member annotations Annotations
 * @member checksums Checksums
 * @member comment Comments
 * @member fileContributors List of contributors
 * @member fileName Filename
 * @member fileTypes List of file types
 * @member licenseComments License comments
 * @member licenseConcluded License concluded
 * @member licenseInfoInFiles List of licenses
 * @member notice Notice
 * @member attributionText Attribution text
 * @see https://spdx.github.io/spdx-spec/4-file-information/
 */
export interface IFile {
  SPDXID: string;
  annotations?: {
    annotationDate: string;
    annotationType: string;
    annotator: string;
    comment?: string;
  }[];
  checksums: {
    algorithm: string;
    checksumValue: string;
  }[];
  comment?: string;
  copyrightText?: string;
  fileContributors: string[]; // 0..*
  fileName: string;
  fileTypes: IFileType[]; // 0..*
  licenseComments?: string;
  licenseConcluded?: string;
  licenseInfoInFiles: string[]; // 0..*
  notice?: string;
  attributionTexts: string[]; // 0..*
}

/**
 * SPDX Relationship
 * @interface IRelationship
 * @member spdxElementId The SPDX ID of the element
 * @member relationshipType The type of relationship
 * @member relatedSpdxElement The SPDX ID of the related element
 * @see https://spdx.github.io/spdx-spec/3-relationships-between-SPDX-elements/
 */
interface IRelationship {
  spdxElementId: string;
  relationshipType: "DESCRIBES";
  relatedSpdxElement: string;
}

/**
 * Simplified implementation of the SPDX 2.3 specification,
 * used for generating a Software Bill of Materials for the
 * files scanned against REUSE compliance.
 * @interface ISoftwareBillOfMaterials
 * @member SPDXID SPDX identity of the document
 * @member spdxVersion SPDX version reference
 * @member name Name of the document as designated by the creator
 * @member documentNamespace SPDX document-specific namespace as a unique absolute URI
 * @member dataLicense License of the SPDX document
 * @member creationInfo Information about the creation of the SPDX document
 * @member relationships Relationships between SPDX elements
 * @member files List of files
 * @see https://spdx.github.io/spdx-spec/2-document-creation-information/
 * @see https://spdx.github.io/spdx-spec/3-relationships-between-SPDX-elements/
 * @see https://spdx.github.io/spdx-spec/4-file-information/
 */
export interface ISoftwareBillOfMaterials {
  SPDXID: string;
  spdxVersion: string;
  name: string;
  documentNamespace: string;
  dataLicense: string;
  creationInfo?: {
    comment: string;
    created: string;
    creators: string[];
    licenseListVersion?: string;
  };
  relationships: IRelationship[];
  files: IFile[];
}

/**
 * SPDX Document
 * @class SoftwareBillOfMaterials
 * @implements ISoftwareBillOfMaterials
 * @see https://spdx.github.io/spdx-spec/2-document-creation-information/
 */
export class SoftwareBillOfMaterials implements ISoftwareBillOfMaterials {
  SPDXID = "SPDXRef-DOCUMENT";
  spdxVersion = "SPDX-2.3";
  dataLicense = "CC0-1.0";
  documentNamespace = "http://spdx.org/spdxdocs/spdx-v2.3-45eae250-b782-46dd-9723-62ec3bed2a7c";

  name: string;
  creationInfo?: {
    comment: string;
    created: string;
    creators: string[];
    licenseListVersion?: string;
  } = undefined;

  relationships: IRelationship[] = [];
  files: IFile[] = [];

  datasource: IDataSource;

  constructor(name: string, datasource: IDataSource) {
    this.name = name;
    this.datasource = datasource;
    this.creationInfo = {
      comment: "Generated by ReuseMe",
      created: new Date().toISOString(),
      creators: ["Tool: ReuseMe-v0"],
    };
  }

  /**
   * Creates a single SPDX File entry for the provided file.
   * @param file The file to create the SPDX entry for
   * @param debianLicenseMap Debian package configuration mapping against the file
   * @returns The SPDX File entry
   */
  private async createFile(file: ISourceFile, debianLicenseMap: Map<string, IFile>) {
    const fileName = getSourceFile(file);

    // First we check whether the file is matched in the Debian package configuration
    const debianFileLicense = debianLicenseMap.get(file.filePath);
    if (
      debianFileLicense !== undefined &&
      (hasValidLicense(debianFileLicense) || hasValidCopyrightText(debianFileLicense))
    )
      return debianFileLicense;

    // Next we check for an available .license file, as part of optimization for large
    // binary files.
    const licenseFileLicense = await parseFile(fileName)//, await this.datasource.getFileContents(file.licensePath));
    if (hasValidLicense(licenseFileLicense) || hasValidCopyrightText(licenseFileLicense)) return licenseFileLicense;

    // Otherwise, we check the original file.
    return await parseFile(fileName);//, await this.datasource.getFileContents(file.filePath));
  }

  /**
   * Creates a list of SPDX File entries based on the current datasource.
   * @returns The list of files
   */
  private async gatherFiles(): Promise<IFile[]> {
    const changedFiles = await this.datasource.getFiles();
    const debianConfig = debian.load(await this.datasource.getFileContents(".reuse/dep5", false));
    const debianLicenseMap = debianConfig ? await debian.licenseMap() : new Map<string, IFile>();

    // Validate each file asynchronously
    return await Promise.all(
      changedFiles
        .filter(
          file =>
            !(
              file.filePath.startsWith("LICENSES/") ||
              file.filePath === ".reuse/dep5" ||
              file.filePath === "LICENSE.txt" ||
              // We will not scan the .license file as stand-alone,
              // but rather as part of the original file parser
              file.source === "license"
            )
        )
        .map(file => this.createFile(file, debianLicenseMap))
    );
  }

  async generate() {
    this.files = await this.gatherFiles();
    this.relationships = this.files.map(file => {
      return {
        spdxElementId: "SPDXRef-DOCUMENT",
        relationshipType: "DESCRIBES",
        relatedSpdxElement: file.SPDXID,
      };
    });
  }

  /**
   * Converts the SPDX document to a JSON object.
   * @returns The SPDX document as a JSON object
   */
  toJSON(): ISoftwareBillOfMaterials {
    return {
      SPDXID: this.SPDXID,
      spdxVersion: this.spdxVersion,
      name: this.name,
      documentNamespace: this.documentNamespace,
      dataLicense: this.dataLicense,
      creationInfo: this.creationInfo,
      relationships: this.relationships,
      files: this.files,
    };
  }
}

/**
 * Creates a SPDX File entry for the provided file
 * @param fileName Filename of the file
 * @param contents Contents of the file
 * @returns SPDX File entry
 */
export async function parseFile(fileName: string): Promise<IFile> {
  const file: IFile = {
    SPDXID: `SPDXRef-${crypto.createHash("SHA1").update(fileName).digest("hex")}`,
    checksums: [{ algorithm: "SHA1", checksumValue: crypto.createHash("SHA1").update(fileName).digest("hex") }],
    fileContributors: [],
    fileName: fileName.startsWith("./") ? fileName : `./${fileName}`,
    fileTypes: [],
    licenseInfoInFiles: ["NOASSERTION"],
    licenseConcluded: "NOASSERTION",
    attributionTexts: [],
  };

  if (!commentIt.isSupported(fileName)) return file;
  for await (const comment of commentIt.extractComments(fileName, { maxLines: 20 })) {
    const contents = comment.contents.map(line => line.value).join("\n")

    // REUSE-IgnoreStart
    const SPDXLicenseHeaderRegex = /SPDX-License-Identifier:\s*(?<identifier>(.*)+)/g;
    const SPDXCopyrightRegex = /^[\W]*(Â©|[Cc]opyright|\([Cc]\)|SPDX-FileCopyrightText:)\s+(?<identifier>(.*)+)/gm;
    const SPDXCopyrightIdentifierRegex = /(?<year>[\d,-\s]*)\s*(?<copyrightHolder>[^<\n\r]*)\s(<(?<contactAddress>.*)>)?/;
    const SPDXFileTagRegex = /SPDX-File(?<key>[A-Za-z]*):\s*(?<value>.*)/g;
    const ReuseIgnoreRegex = /REUSE-IgnoreStart[\s\S]*REUSE-IgnoreEnd/g;
    // REUSE-IgnoreEnd

    // Remove all REUSE-Ignore blocks from the file
    const strippedContents = contents.replace(ReuseIgnoreRegex, "");

    // Ensure that this file contains the minimum set of headers to be REUSE 3.0 compliant
    const licenseMatches = strippedContents.matchAll(SPDXLicenseHeaderRegex);
    for (const match of licenseMatches) {
      if (match?.groups === undefined) continue;
      const license = match.groups?.identifier.trim();
      if (!file.licenseInfoInFiles.includes(license)) file.licenseInfoInFiles.push(license);
    }

    const copyrightMatches = strippedContents.matchAll(SPDXCopyrightRegex);
    for (const match of copyrightMatches) {
      if (match?.groups === undefined) continue;
      if (file.copyrightText !== undefined) continue;
      if (SPDXCopyrightIdentifierRegex.test(match.groups.identifier) === false) continue;
      file.copyrightText = match.groups.identifier.trim();
    }

    const fileTagMatches = strippedContents.matchAll(SPDXFileTagRegex);

    for (const match of fileTagMatches) {
      if (match?.groups === undefined) continue;
      const key = match.groups.key.trim();
      const value = match.groups.value.trim();

      switch (key) {
        case "AttributionText":
          file.attributionTexts.push(value);
          break; // TODO: Multiline support
        case "Comment":
          file.comment = value;
          break; // TODO: Multiline support
        case "Contributor":
          file.fileContributors.push(value);
          break;
        case "LicenseComments":
          file.licenseComments = value;
          break; // TODO: Multiline support
        case "LicenseConcluded":
          file.licenseConcluded = value;
          break;
        case "LicenseInfoInFile":
          if (file.licenseInfoInFiles.includes(value) === false) file.licenseInfoInFiles.push(value);
          break;
        case "Notice":
          file.notice = value;
          break; // TODO: Multiline support
        case "Type":
          file.fileTypes.push(value as IFileType);
          break; // TODO: Literal type checking
      }
    }

    if (file.licenseInfoInFiles.length > 1) {
      // Remove the element "NOASSERTION" if there are other licenses specified in the "LicenseInfoInFile
      file.licenseInfoInFiles = file.licenseInfoInFiles.filter(license => license !== "NOASSERTION");
    }
  }
  return file;
}

export function hasValidLicense(file: IFile): boolean {
  return (
    file.licenseInfoInFiles.length > 0 &&
    !(file.licenseInfoInFiles.length === 1 && file.licenseInfoInFiles[0] === "NOASSERTION")
  );
}

export function hasValidCopyrightText(file: IFile): boolean {
  return file.copyrightText !== undefined && file.copyrightText !== "";
}

/**
 * Validates whether the provided header is a valid SPDX header.
 * @param header SPDX header to validate
 * @returns True if the header is valid, false otherwise
 */
export function isReuseCompliant(file: IFile): boolean {
  return hasValidLicense(file) && hasValidCopyrightText(file);
}

/**
 * Extracts all individual license names from the license information in file.
 * @param file SPDX file to extract the licenses from
 * @returns List of individual licenses
 */
export function getIndividualLicences(file: IFile): string[] {
  return file.licenseInfoInFiles
    .filter(license => license !== "NOASSERTION")
    .map(license => license.split(/( AND | OR )/))
    .flat()
    .filter(license => license !== " AND " && license !== " OR ");
}
